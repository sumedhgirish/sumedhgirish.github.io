
[{"content":"","date":"15 August 2025","externalUrl":null,"permalink":"/series/container-virtualization/","section":"Series","summary":"","title":"Container Virtualization","type":"series"},{"content":"","date":"15 August 2025","externalUrl":null,"permalink":"/","section":"Layer Zero","summary":"","title":"Layer Zero","type":"page"},{"content":" Abstract # It so happens with many topics in Computer Science that it is far easier to grasp a concept when it is taught via demonstration and hands-on experience than when it is simply read from a book, or taught in a class lecture. With recent development in containerization of various systems, it is now possible to craft containers that provide such an experience while being easier to set up and deploy in various different environments. Such a method is not without its shortcomings however. Since a container seeks to run its own miniature subsystem, it can take up significant amount of RAM and processing power which may not be readily available to everyone who wishes to use the container. Also, setting up a container without previous knowledge on how they work can be equally challenging and time-consuming. For any container that gets deployed on a machine, there is no way for an instructor ar admin to view and verify progess made, and any edits that are made to the source container thereafter cannot be easily deployed to client systems without some sort of external interaction and/or loosing existing progress. This makes containers hard to distribute and maintain in an educational context.\nWe seek to create a system that allows us to create, update and manage many such containers easily, while making them easy to deploy and maintain at scale.\nIntroduction # As a first thought, what one might do to solve such an issue might be to keep a central copy of the updated container image, and expect the clients to update themselves to match this central image. This would require a server to store all required containers in thier updated state and serve them to the clients whenever necessary. However, this does not solve the problem of still requiring the clients to download and update containers to be able to use them. Thus, instead of keeping only one copy of the container, the server could maintain a separate copy for each client using the container and allow the client to connect to the server and gain access to it.\nA first approach While such a system does help with overcoming some of our previous challenges, it does not come close to achieving what we initially set out to do. While we do solve the problem of having to individually require each client to update and run thier own copy of the container, having a single server host all of the containers creates its own set of issues. Namely, how do we reliably host a large number of containers? Assuming that a course has around 300 applicants, and there are about 10 such courses in an institution that seek to use such a server, we arrive at a whopping 3000 containers that need to run simultaneously while serving a similar number of clients over a network! Moreover, in case a new client has to be accomodated, a new container will need to be initialized to accomodate the new entry, which may take large amounts of time. If a client looses connection to the server or a container fails, the server will have no way to restore the clients work/progress. Finally, since all the jobs running on the server are similar, most commands will also be similar. This means that if a container uses a specific set of unique commands repeatedly, then each those commands will be run atleast 3000 different times, even though the output could be achieved by running the command only once.\nIt is abundantly clear that this is not the best approach.\nNew Approach # Instead of running multiple copies of the same program, one can instead store the states of the container as it runs. The \u0026lsquo;state\u0026rsquo; of a program could be defined as the value of its cpu registers, along with any IO operations it tried to perform and the content of its memory. Since all clients use the same container, all clients would initially begin at the same inital state. Whenever a client issues a command, the container will execute that command, and in-turn change its state. Thus, we could also store how the state of the container changed when the command was issued to track progress. For example, if the container changed its state from q0 to q1 after recieving an intruction i1, then we could store that running i1 changed q1 in q0. If we wanted to arrive at the resultant state when i1 was run from state q0, we could then simply apply the changes stored in q1 to the state at q0. Thus for any sequence of instructions whose states were stored in memory, the final resultant state could be attained by consecutively applying the changes used to arrive at each intermediate state in that sequence. Thus, all commands from any given state would only need to be executed once and then can be sebsequently retrieved from the program cache! Thus, commands that have known state deltas(changes) can be simulated without running them on the container.\nVirtualizer for containers To manage commands that arrive while the container is busy, we maintain a queue that stores intructions that are yet to be executed, and attempts to simplify those intructions by using data from the cache. When the running container halts, the next program in the queue can be loaded into the container and allowed to run, while the current output is returned to the client and saved. Thus a single container can handle requests from multiple clients concurrently, reducing the number of containers needed to serve all of the clients dramatically.\nAlso as more and more commands are executed, more and more states are reached, thus requiring lesser number of intructions to be computed by the container. Thus as time goes on, the burden on the server will decrease.\nIt is possible to use this behaviour to generate cache trees that account for most common commands and store it permanently for future use.\nConclusion # The process by which we abstract away the container(resource) itself from the the users of the resource so that multiple independent users can share the same resource is called Virtualization. By means of virtualization, it is possible to solve earlier issues while keeping the system centralized and easy to maintain.\n","date":"15 August 2025","externalUrl":null,"permalink":"/projects/virtualizing-containers/","section":"Projects","summary":"","title":"On Virtualizing Containers","type":"projects"},{"content":"","date":"15 August 2025","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"15 August 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]